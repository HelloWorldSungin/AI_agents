#!/usr/bin/env python3
"""
Agent Composition Tool

This script composes complete agent prompts by combining:
1. Base agent prompts
2. Platform augmentations
3. Project-specific context
4. Tool definitions
5. Anthropic Skills
6. Memory configurations

Usage:
    python compose-agent.py --config config.yml --agent frontend_developer
    python compose-agent.py --config config.yml --all
"""

import argparse
import json
import os
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional

try:
    import yaml
except ImportError:
    print("Error: PyYAML is required. Install with: pip install pyyaml")
    sys.exit(1)


class AgentComposer:
    """Composes agent prompts from modular components."""

    def __init__(self, library_path: Path, project_path: Path):
        self.library_path = library_path
        self.project_path = project_path

    def load_markdown(self, path: Path) -> str:
        """Load a markdown file."""
        try:
            with open(path, 'r', encoding='utf-8') as f:
                return f.read()
        except FileNotFoundError:
            print(f"Warning: File not found: {path}")
            return ""
        except Exception as e:
            print(f"Error reading {path}: {e}")
            return ""

    def resolve_skill_path(self, skill: str) -> Optional[Path]:
        """
        Resolve skill path from skill name.

        Supports both formats:
        - "skill-name" -> looks in skills/core/skill-name.md
        - "category/skill-name" -> looks in skills/category/skill-name.md

        Checks both library and project-specific skills directories.

        Args:
            skill: Skill identifier

        Returns:
            Path to skill file if found, None otherwise
        """
        # Check if skill includes category
        if '/' in skill:
            # Format: category/skill-name
            skill_path = f"skills/{skill}.md"
        else:
            # Format: skill-name (default to core category)
            skill_path = f"skills/core/{skill}.md"

        # Check library skills directory first
        library_skill = self.library_path / skill_path
        if library_skill.exists():
            return library_skill

        # Check project-specific skills directory
        project_skill = self.project_path / ".ai-agents" / skill_path
        if project_skill.exists():
            return project_skill

        return None

    def count_tokens(self, text: str) -> int:
        """
        Estimate token count for text.

        Uses a simple approximation: ~4 characters per token for English text.
        This is a rough estimate; actual token count may vary.

        Args:
            text: Text to count tokens for

        Returns:
            Estimated token count
        """
        # Simple approximation: 4 characters per token
        # This is conservative; actual ratio is often closer to 3-3.5
        return len(text) // 4

    def analyze_token_budget(self, content: str, agent_name: str, agent_config: Dict) -> Dict:
        """
        Analyze token usage and budget.

        Args:
            content: Composed agent content
            agent_name: Name of the agent
            agent_config: Agent configuration

        Returns:
            Dictionary with token analysis results
        """
        total_tokens = self.count_tokens(content)

        # Default context window for Claude Sonnet 4.5 is 200k tokens
        max_context = 200000

        # We want to leave plenty of room for conversation
        # Recommendation: agent prompt should be < 12k tokens (6% of context)
        recommended_max = 12000

        # Warning threshold at 75% of recommended max
        warning_threshold = int(recommended_max * 0.75)

        result = {
            'total_tokens': total_tokens,
            'max_context': max_context,
            'recommended_max': recommended_max,
            'warning_threshold': warning_threshold,
            'percentage_of_context': (total_tokens / max_context) * 100,
            'within_budget': total_tokens <= recommended_max,
            'needs_warning': total_tokens >= warning_threshold
        }

        return result

    def compose_agent(
        self,
        agent_name: str,
        agent_config: Dict,
        project_config: Dict
    ) -> str:
        """
        Compose a complete agent prompt from configuration.

        Args:
            agent_name: Name of the agent
            agent_config: Agent-specific configuration
            project_config: Project-wide configuration

        Returns:
            Complete agent prompt as string
        """
        components = []

        # Header
        components.append(f"""# Composed Agent: {agent_name}
# Generated by Agent Composition Tool
# Project: {project_config.get('project_name', 'Unknown')}
# Library Version: {project_config['agent_library']['version']}
# Generated: {self._get_timestamp()}

---

""")

        # 1. Load base agent
        base_path = self.library_path / agent_config['base']
        if base_path.exists():
            components.append("# ========================================")
            components.append("# BASE AGENT")
            components.append("# ========================================\n")
            components.append(self.load_markdown(base_path))
            components.append("\n\n")
        else:
            print(f"Error: Base agent not found: {base_path}")
            return ""

        # 2. Load platform augmentations
        if 'platforms' in agent_config and agent_config['platforms']:
            components.append("# ========================================")
            components.append("# PLATFORM AUGMENTATIONS")
            components.append("# ========================================\n")

            for platform in agent_config['platforms']:
                platform_path = self.library_path / platform
                if platform_path.exists():
                    components.append(f"\n## Platform: {platform}\n")
                    components.append(self.load_markdown(platform_path))
                    components.append("\n")
                else:
                    print(f"Warning: Platform augmentation not found: {platform_path}")

            components.append("\n")

        # 3. Load project context
        if 'project_context' in agent_config and agent_config['project_context']:
            components.append("# ========================================")
            components.append("# PROJECT CONTEXT")
            components.append("# ========================================\n")

            for context_file in agent_config['project_context']:
                context_path = self.project_path / context_file
                if context_path.exists():
                    components.append(f"\n## Context: {context_file}\n")
                    components.append(self.load_markdown(context_path))
                    components.append("\n")
                else:
                    print(f"Warning: Context file not found: {context_path}")
                    # Create placeholder
                    components.append(f"\n## Context: {context_file}\n")
                    components.append(f"<!-- TODO: Create {context_file} -->\n")

            components.append("\n")

        # 4. Load tool definitions
        if 'tools' in agent_config and agent_config['tools']:
            components.append("# ========================================")
            components.append("# TOOLS")
            components.append("# ========================================\n")

            for tool in agent_config['tools']:
                tool_path = self.library_path / tool
                if tool_path.exists():
                    components.append(f"\n## Tool: {tool}\n")
                    components.append(self.load_markdown(tool_path))
                    components.append("\n")
                else:
                    print(f"Warning: Tool definition not found: {tool_path}")

            components.append("\n")

        # 5. Load Anthropic Skills
        if 'skills' in agent_config and agent_config['skills']:
            components.append("# ========================================")
            components.append("# ANTHROPIC SKILLS")
            components.append("# ========================================\n")

            for skill in agent_config['skills']:
                # Resolve skill path from library or project directory
                skill_path = self.resolve_skill_path(skill)
                if skill_path:
                    components.append(f"\n## Skill: {skill}\n")
                    components.append(self.load_markdown(skill_path))
                    components.append("\n")
                else:
                    print(f"Warning: Skill not found: {skill}")
                    print(f"  Searched in library: skills/{skill}.md")
                    print(f"  Searched in project: .ai-agents/skills/{skill}.md")

            components.append("\n")

        # 6. Add project-specific instructions
        components.append("# ========================================")
        components.append("# PROJECT-SPECIFIC CONFIGURATION")
        components.append("# ========================================\n")

        project_info = self._generate_project_info(project_config)
        components.append(project_info)

        # 7. Add coordination info
        if 'coordination' in agent_config:
            coord_info = self._generate_coordination_info(
                agent_name,
                agent_config['coordination']
            )
            components.append("\n")
            components.append(coord_info)

        # 8. Add memory configuration
        if 'memory' in agent_config and agent_config['memory'].get('enabled'):
            memory_info = self._generate_memory_info(agent_config['memory'])
            components.append("\n")
            components.append(memory_info)

        return "".join(components)

    def _generate_project_info(self, project_config: Dict) -> str:
        """Generate project-specific information section."""
        info = []

        info.append("## Project Information\n")
        info.append(f"**Project**: {project_config.get('project_name', 'Unknown')}\n")
        info.append(f"**Description**: {project_config.get('description', 'N/A')}\n")

        if 'project' in project_config:
            proj = project_config['project']

            if 'tech_stack' in proj:
                info.append("\n### Technology Stack\n")
                for category, technologies in proj['tech_stack'].items():
                    if technologies:
                        info.append(f"- **{category.title()}**: {', '.join(technologies)}\n")

            if 'coding_standards' in proj:
                standards = proj['coding_standards']
                info.append("\n### Coding Standards\n")
                info.append(f"- **Linter**: {standards.get('linter', 'N/A')}\n")
                info.append(f"- **Formatter**: {standards.get('formatter', 'N/A')}\n")
                info.append(f"- **Style Guide**: {standards.get('style_guide', 'N/A')}\n")
                info.append(f"- **Test Framework**: {standards.get('test_framework', 'N/A')}\n")
                info.append(f"- **Min Test Coverage**: {standards.get('min_test_coverage', 'N/A')}%\n")

            if 'git_workflow' in proj:
                git = proj['git_workflow']
                info.append("\n### Git Workflow\n")
                info.append(f"- **Main Branch**: {git.get('main_branch', 'main')}\n")
                info.append(f"- **Development Branch**: {git.get('development_branch', 'develop')}\n")
                info.append(f"- **Branch Naming**: `{git.get('branch_naming', 'N/A')}`\n")
                info.append(f"- **Commit Format**: {git.get('commit_message_format', 'N/A')}\n")

            if 'quality_gates' in proj:
                gates = proj['quality_gates']
                info.append("\n### Quality Gates\n")
                info.append("Before merging, ensure:\n")
                if gates.get('require_tests'):
                    info.append("- ✓ All tests passing\n")
                if gates.get('require_code_review'):
                    info.append("- ✓ Code review approved\n")
                if gates.get('require_passing_ci'):
                    info.append("- ✓ CI pipeline passing\n")
                if gates.get('block_on_lint_errors'):
                    info.append("- ✓ No linting errors\n")
                if 'min_test_coverage' in gates:
                    info.append(f"- ✓ Test coverage ≥ {gates['min_test_coverage']}%\n")

        return "".join(info)

    def _generate_coordination_info(self, agent_name: str, coordination: Dict) -> str:
        """Generate coordination information section."""
        info = []

        info.append("## Coordination\n")

        if 'manages' in coordination:
            info.append(f"\n**You manage these agents:**\n")
            for agent in coordination['manages']:
                info.append(f"- {agent}\n")

        if 'reports_to' in coordination:
            info.append(f"\n**You report to:** {coordination['reports_to']}\n")

        if 'collaborates_with' in coordination:
            info.append(f"\n**You collaborate with:**\n")
            for agent in coordination['collaborates_with']:
                info.append(f"- {agent}\n")

        info.append("\n**Communication Protocol:**\n")
        info.append("- Use structured JSON messages as defined in the communication protocol schema\n")
        info.append("- Report progress at 25%, 50%, 75%, and 100% completion\n")
        info.append("- Immediately report blockers\n")
        info.append("- Request coordination when needed\n")

        return "".join(info)

    def _generate_memory_info(self, memory_config: Dict) -> str:
        """Generate memory configuration section."""
        info = []

        info.append("## Memory & Context Management\n")
        info.append(f"\n**Memory enabled:** Yes\n")
        info.append(f"**Retention policy:** {memory_config.get('retention_policy', 'medium_priority')}\n")

        if 'checkpoint_frequency' in memory_config:
            info.append(f"**Checkpoint frequency:** Every {memory_config['checkpoint_frequency']} turns\n")

        info.append("\n**Context Management:**\n")
        info.append("- Monitor context usage continuously\n")
        info.append("- Create checkpoint at 75% context usage\n")
        info.append("- Alert manager at 85% context usage\n")
        info.append("- Emergency checkpoint and restart at 95%\n")

        if 'vector_db' in memory_config:
            vdb = memory_config['vector_db']
            info.append(f"\n**Vector Database:**\n")
            info.append(f"- Provider: {vdb.get('provider', 'N/A')}\n")
            info.append(f"- Collection: {vdb.get('collection', 'N/A')}\n")

        return "".join(info)

    def _get_timestamp(self) -> str:
        """Get current timestamp in ISO format."""
        from datetime import datetime
        return datetime.now().isoformat()

    def save_agent(self, agent_name: str, content: str, output_dir: Path, agent_config: Dict):
        """
        Save composed agent to file with token analysis.

        Args:
            agent_name: Name of the agent
            content: Composed agent content
            output_dir: Output directory
            agent_config: Agent configuration for analysis
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        output_file = output_dir / f"{agent_name}.md"

        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(content)

        # Analyze token usage
        analysis = self.analyze_token_budget(content, agent_name, agent_config)

        print(f"✓ Saved: {output_file}")
        print(f"  Tokens: {analysis['total_tokens']:,} / {analysis['recommended_max']:,} recommended")
        print(f"  Context usage: {analysis['percentage_of_context']:.2f}%")

        # Warn if approaching or exceeding budget
        if not analysis['within_budget']:
            print(f"  ⚠️  WARNING: Agent prompt exceeds recommended size!")
            print(f"  Recommendation: {analysis['total_tokens'] - analysis['recommended_max']:,} tokens over budget")
            self._suggest_reductions(agent_name, agent_config)
        elif analysis['needs_warning']:
            print(f"  ⚠️  Approaching token budget limit")
            print(f"  Remaining budget: {analysis['recommended_max'] - analysis['total_tokens']:,} tokens")

    def _suggest_reductions(self, agent_name: str, agent_config: Dict):
        """Suggest ways to reduce token usage."""
        suggestions = []

        if 'skills' in agent_config and agent_config['skills']:
            suggestions.append(f"  - Consider removing {len(agent_config['skills'])} skill(s)")
            suggestions.append(f"    Skills: {', '.join(agent_config['skills'])}")

        if 'platforms' in agent_config and len(agent_config['platforms']) > 1:
            suggestions.append(f"  - Consider consolidating {len(agent_config['platforms'])} platform augmentations")

        if 'project_context' in agent_config and len(agent_config['project_context']) > 3:
            suggestions.append(f"  - Review {len(agent_config['project_context'])} project context files")

        if suggestions:
            print(f"\n  Suggestions to reduce token usage:")
            for suggestion in suggestions:
                print(suggestion)


def main():
    parser = argparse.ArgumentParser(
        description="Compose AI agent prompts from modular components"
    )
    parser.add_argument(
        "--config",
        required=True,
        help="Path to project configuration file (YAML)"
    )
    parser.add_argument(
        "--agent",
        help="Name of specific agent to compose (e.g., 'frontend_developer')"
    )
    parser.add_argument(
        "--all",
        action="store_true",
        help="Compose all agents defined in config"
    )
    parser.add_argument(
        "--output",
        default=".ai-agents/composed",
        help="Output directory for composed agents (default: .ai-agents/composed)"
    )
    parser.add_argument(
        "--library",
        help="Path to AI agents library (default: auto-detect)"
    )

    args = parser.parse_args()

    # Load configuration
    config_path = Path(args.config)
    if not config_path.exists():
        print(f"Error: Configuration file not found: {config_path}")
        sys.exit(1)

    with open(config_path, 'r') as f:
        config = yaml.safe_load(f)

    # Determine paths
    project_path = config_path.parent.parent  # Assume config is in .ai-agents/

    if args.library:
        library_path = Path(args.library)
    else:
        # Try to find library
        possible_paths = [
            project_path / ".ai-agents" / "library",
            project_path.parent / "AI_agents",
            Path.cwd()
        ]
        library_path = None
        for path in possible_paths:
            if (path / "base" / "software-developer.md").exists():
                library_path = path
                break

        if not library_path:
            print("Error: Could not find AI agents library.")
            print("Please specify library path with --library")
            sys.exit(1)

    print(f"Library path: {library_path}")
    print(f"Project path: {project_path}")

    # Initialize composer
    composer = AgentComposer(library_path, project_path)

    # Determine which agents to compose
    agents_to_compose = []
    if args.all:
        agents_to_compose = list(config['agents'].keys())
    elif args.agent:
        if args.agent not in config['agents']:
            print(f"Error: Agent '{args.agent}' not found in configuration")
            print(f"Available agents: {', '.join(config['agents'].keys())}")
            sys.exit(1)
        agents_to_compose = [args.agent]
    else:
        print("Error: Specify --agent <name> or --all")
        sys.exit(1)

    # Compose agents
    output_dir = Path(args.output)
    print(f"\nComposing {len(agents_to_compose)} agent(s)...\n")

    for agent_name in agents_to_compose:
        print(f"Composing {agent_name}...")
        agent_config = config['agents'][agent_name]

        composed = composer.compose_agent(agent_name, agent_config, config)

        if composed:
            composer.save_agent(agent_name, composed, output_dir, agent_config)
        else:
            print(f"✗ Failed to compose {agent_name}")

    print(f"\n✓ Done! Composed agents saved to: {output_dir}")
    print(f"\nNext steps:")
    print(f"1. Review composed agents in {output_dir}/")
    print(f"2. Use these prompts to initialize your AI agents")
    print(f"3. Ensure project context files exist in .ai-agents/context/")


if __name__ == "__main__":
    main()
